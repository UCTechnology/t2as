/*
 *----------------------------------------------------------------------
 *    UCT T2AS (T-Kernel 2.0 AeroSpace) DevKit tuned for ASP-LEON5
 *
 *    Copyright (c) 2021 UC Technology. All Rights Reserved.
 *----------------------------------------------------------------------
 *
 *    Version:   1.00.00
 *    Released by UC Technology (http://www.uctec.com/) at 2021/11/26.
 *
 *----------------------------------------------------------------------
 */

==============================================================================
        T2AS (T-Kernel 2.0 AeroSpace) ( ASP-LEON5 ) 実装仕様書
==============================================================================
                                                               Version 1.00.00

1. 概要

本書は、T2AS(T-Kernel 2.0 AeroSpace) の LEON-XCKU (CPU LEON5) (以降、ASP-LEON5
と記述) への実装における T-Monitor、T-Kernel の実装依存項目に関する仕様書であ
る。

  ※ 本実装は「T-Kernel 2.0ソースコードパッケージ Ver 2.01.03」に含まれる T-
     Kernel ソースコードを使用している。

  ※ 本実装の対象ハードウェアとして、Xilinx Kintex UltraScale FPGA KCU105
     Evaluation Kit を使用している。

  ※ 本実装は開発環境として LEON-XCKU 用のコンパイラおよびランタイムライブラリ
     である BCC2: Bare-C Cross-Compiler System GCC 10.2.0 の使用を前提としてい
     る。

2. 全体の実装仕様

2.1 基本環境

      コンパイラおよびランタイムライブラリとして BCC (下記)を使用する。

      BCC2: Bare-C Cross-Compiler System for LEON2/3/4/5 GCC 10.2.0

      BCC には Plug&Play と呼ばれる機能があり、FPGA の設計に追従して、ハードウ
      ェア構成の情報が自動的にソフトウェアに反映される。
      このような BCC の機能を利用できるように、BCC により提供されている機能を
      ベースにシステムを構築する。

      BCC の詳細については、BCC のドキュメント「BCC User's Manual」を参照され
      たい。

      なお、各種のアドレスなどは BCC により自動取得されるため、本書には具体的
      なアドレスなどは原則記載されていない。アドレスが記載されていても、それは
      一例であり、実際とは異なる場合がある。


2.2 メモリーマップ

  (1) 全体

      大まかな配置は以下のようになる。詳細は、FPGA の設計情報を参照のこと。

           0x00000000 +-----------------------+
                      |ROM 領域               |
           0x40000000 +-----------------------+
                      |RAM 領域               |
           0x80000000 +-----------------------+
                      |I/O 領域               |
           0xffffffff +-----------------------+

      ・仮想記憶には対応していないため、共有空間と固有空間の明確な区別はない。


  (2) RAM 概略

           0x40000000 +-----------------------+
                      |プログラム             |
                      |       text data bss   |
                      +-----------------------+ ← ramtop
                      |T-Kernel ヒープ        |
                      |                       |
                      +-----------------------+ ← ramend
                      |BCC ヒープ             |
                      |               (32KB)  |
                      +-----------------------+
                      |BCC 初期スタック       | 一時スタックとしても使用
                      |               (8KB)   |
                      +-----------------------+

      ・malloc() は BCC のライブラリであり、BCC ヒープから割り当てられる。
      ・T-Kernel ヒープは、T-Kernel のメモリー管理機能により管理される。
        タスクのスタック、各種オブジェクト用のメモリー、Kmalloc(), Vmalloc(),
        Smalloc() などは、T-Kernel ヒープから割り当てられる。

      ・BCC 初期スタックのサイズは、BCC ライブラリ内で設定されている。
        (BCC ライブラリソース bcc-2.2.0-gcc/src/libbcc/shared/sbrk.c を参照)
      ・BCC ヒープのサイズは、モニタ起動時に設定している。
        (ASP_LEON5/monitor/src/asp_leon5/bccmain.c を参照)
      ・T-Kernel ヒープは、これらの領域を確保したあとの残り全てとなる。
      ・ramtop/ramend は、システム起動時にシステム共有情報に設定される。


2.3 ROM 情報

      typedef struct {
              FP      kernel;         /* OS 起動アドレス */
              UB      *sysconf;       /* SYSCONF 先頭 */
              UB      *devconf;       /* DEVCONF 先頭 */
              void    *userarea;      /* RAM ユーザーエリア先頭 */
              FP      userinit;       /* ユーザー初期化プログラムアドレス */
              FP      resetinit;      /* リセット初期化プログラムアドレス */
              UW      dbgport_bps;    /* デバッグ用シリアルポート速度 (bps) */
              VW      rsv[9];         /* 予約 (常に０) */
              UW      rd_type;        /* ROM ディスク種別 */
              UW      rd_blksz;       /* ROM ディスクブロックサイズ */
              UW      rd_saddr;       /* ROM ディスク開始アドレス */
              UW      rd_eaddr;       /* ROM ディスク終了アドレス */
              VW      rsv2[12];       /* 予約 (常に０) */
      } RomInfo;

        kernel        T-Kernel の起動アドレスを指定する。
                      T-Monitor はこのアドレスへジャンプして OS を起動する。

        sysconf       SYSCONF を格納した先頭アドレスを指定する。
        devconf       DEVCONF を格納した先頭アドレスを指定する。

        userarea      RAM の内、T-Kernel の管理から外すユーザーエリアの先頭ア
                      ドレスを指定する。通常この指定は使用しないため、NULL を
                      指定する。

        userinit      ユーザー作成の初期化プログラムのエントリーアドレスを指定
                      する。
                      T-Kernel 起動後、ここへ登録されたプログラムを実行する。
                      NULL を指定した場合は、ユーザー初期化プログラムは実行し
                      ない。

        resetinit     ユーザー作成のリセット初期化プログラムのエントリーアドレ
                      スを指定する。
                      リセット処理後、ここへ登録されたプログラムを実行する。
                      NULL を指定した場合は、リセット初期化プログラムは実行し
                      ない。
                      拡張ボードなどのハードウェア初期化処理が T-Kernel 起動以
                      前に必要な場合に指定する。

        dbgport_bps   デバッグ用シリアルポートの通信速度を bps で指定する。
                      0 を指定した場合は、デフォルト設定(19200 bps)となる。

      rd_xxxx は、ROM 上にあるディスクを指定する。存在しないときは、すべて 0
      とする。
      ※ 本システムでは、ROM ディスクは存在しないので、すべて 0 を設定する。

        rd_type       ディスクタイプ (1 : ROM ディスク (書き込み不可))
        rd_blksz      ディスクブロックサイズ(通常は 512)
        rd_saddr      ROM ディスク領域の開始アドレス
        rd_eaddr      ROM ディスク領域の終了アドレス + 1


2.4 システム共有情報

      typedef struct {
      (*1)    VP      ramtop;         /* RAM 空き領域先頭 (RAM_TOP) */
      (*1)    VP      ramend;         /* RAM 空き領域終端 (RAM_END) */
              UB      *sysconf;       /* SYSCONF 先頭 */
              UB      *devconf;       /* DEVCONF 先頭 */
              W       taskindp;       /* タスク独立部フラグ */
              UW      loop64us;       /* 64μ秒当りのループカウント */
              BootMode bm;            /* ブートモード */
              VW      rsv[9];         /* 予約 */
      } SysCommonInfo;

      (*1)は、T-Monitor で設定する情報。

        taskindp      T-Kernel/OS によってタスク独立部フラグとして使用される。
                      = 0 : タスク部
                      > 0 : タスク独立部

  (1) T-Monitor

      システム起動時およびブート開始時に、システム共有情報を初期化する。

        ramtop,ramend RAM の空き領域の先頭と終端のアドレスを設定する。ramend -
                      ramtop が空き領域のサイズとなる。

      これら以外のシステム共有情報はすべて０クリアする。

  (2) T-Kernel 起動処理

      起動処理の最初に下記のように設定する。

        sysconf       ROM 情報から取得した SYSCONF の先頭アドレス
        devconf       ROM 情報から取得した DEVCONF の先頭アドレス
        loop64us      64μ秒当りのループカウント
        bm            ブートモード (本システムでは 0)


2.5 保護レベル／スタック

      保護レベル      プロセッサモード(PSR.S)
          0           1:スーパーバイザーモード
          1           1:スーパーバイザーモード
          2           1:スーパーバイザーモード
          3           0:ユーザーモード

      T-Kernel では、PSR レジスタの S ビットの切り替えのみ行う。メモリ管理機能
      (MMU)の管理は行わない。

      スタックは、全ての保護レベルでシステムスタックとユーザースタックが統合さ
      れ１本になる。保護レベルの遷移によるスタックの切替えはない。


2.6 TRAP 命令の割り当て

      trap 0〜15      予約 (一部を BCC が使用している)
      trap 16         T-Monitor サービスコール                (T-Monitor)
      trap 17         T-Kernel システムコール・拡張 SVC       (T-Kernel)
      trap 18         デバッガサポート機能                    (T-Kernel)
      trap 19         タスク例外からの復帰                    (T-Kernel)
      trap 20〜127    予備


2.7 例外・割込ハンドラ

      BCC が提供する Trap API および Interrupt API を使用する。


2.8 システムコール

      レジスタの保存規則や引数の受け渡しは、C 言語の関数呼出の形式に準拠する。
      C 言語における、基本的なレジスタの割り当て規則は次の通り。

      %g0             固定値 0
      %g1             一時レジスタ            (v)
      %g2〜%g7        グローバルレジスタ      (v)
      %o0〜%o5        関数引数・戻り値        (v)
      %o6=%sp         スタックポインタ
      %o7             関数呼出元アドレス      (*1)
      %l0〜%l7        ローカルレジスタ
      %i0〜%i5        入力レジスタ
      %i6=%fp         フレームポインタ
      %i7             関数戻りアドレス

      (v)で示したレジスタがシステムコール等の呼出によって破壊される。それ以外
      のレジスタは保存される。
      (*1) C 言語の関数呼出では %o7 は保存されないが、システムコールの呼出(trap)
      では、%o7 も保存されるものとする。

  (1) T-Monitor サービスコール

      %g2     機能コード
      %o0     第１引数
      %o1     第２引数
      %o2     第３引数
      %o3     第４引数
      ta      16
      %o0     戻り値

      引数の最大数は４となる。
      上記のようにレジスタに引数と機能コードを設定して、ta 16 により呼び出す。

  (2) T-Kenrel システムコール

      %g2     機能コード (＜0)
      %o0     第１引数
      %o1     第２引数
      %o2     第３引数
      %o3     第４引数
      %o4     第５引数
      %o5     第６引数
      ta      17
      %o0     戻り値

      引数の最大数は６となる。
      上記のようにレジスタに引数と機能コードを設定して、ta 17 により呼び出す。
      64bit 長(long long)の引数は、引数２つ分の領域を使用する。
      T-Kernel/DS のサービスコールも同様だが、ta 18 を使用する。

  (3) 拡張 SVC

      %g2     機能コード (≧0)
      %o0     引数パケット
      ta      17
      %o0     戻り値

      引数はすべてパケット化し、パケットの先頭アドレスを %o0 レジスタに設定し
      て、ta 17 により呼び出す。
      パケットは通常スタックに作成するが、他の場所でもよい。引数はパケット化す
      るため、数や型に制限はない。


2.9 システムの起動

      システムの起動は、T-Monitor により次の手順で行う。

      1.システムの起動に必要なハードウエアの初期化を行う。
      2.システム共有情報を初期化する。
      3.ROM 情報の kernel に指定された OS 起動アドレスへジャンプする。

      ROM 情報の kernel に格納された OS 起動アドレスを参照し、そのアドレスが
      NULL でなければ、そのアドレスへジャンプすることで OS を起動する。
      OS 起動アドレスが NULL であれば ROM 起動は行われず、T-Monitor のコマンド
      入力待ち状態となる。

      OS へ制御を移すときの CPU の状態は次の通りである。

              PSR レジスタ
                S   = 1       スーパーバイザーモード
                ET  = 1       例外許可
                PIL = 15      割込禁止(最高優先度は禁止されない)
                EF  = 0       FPU 無効
                EC  = 0       コプロセッサ無効

              %sp     モニタスタック
              %o0     0 (ROM 起動であることを示す)
              その他の汎用レジスタは不定

      スタックポインタ %sp は、T-Monitor のスタック領域(モニタスタック)を指し
      ている。OS 起動処理中このモニタスタックが使用される。


2.10 ユーザー初期化プログラム

      ユーザー初期化プログラムは、ユーザー作成のプログラムなどを起動／終了する
      ためのユーザー定義のルーチンである。ユーザー初期化プログラムは、初期起動
      タスクから次の形式で呼び出される。

              INT  userinit( INT ac, UB **av )

              ac      = 0     起動時呼出
                      = -1    終了時呼出

              戻り値   1      usermain を起動
                       0      システム終了(停止)
                      -1      リセット(再起動)

      システム起動時に ac = 0 で呼び出され、システム終了時に ac = -1 で呼び出
      される。終了時の呼出(ac = -1)では、戻り値は無視される。
      処理の概略は次のようになる。

              fin = userinit(0, NULL);
              if ( fin > 0 ){
                      fin = usermain();
              }
              userinit(-1, NULL);

      ユーザー初期化プログラムは、初期起動タスクのコンテキストで実行される。

      ユーザープログラムの起動処理を行った後は、２種類の選択がある。
      (A) ユーザープログラムが終了するまで待った後、userinit() からリターンす
          る。
      (B) ユーザープログラムの終了を待たずに userinit() からリターンする。

      いずれの場合も、usrinit() からの戻り値によって、その後の処理を選択できる。


2.11 リセット初期化プログラム

      リセット初期化プログラムは、拡張ボードなどのハードウェアの初期化処理を、
      リセット直後に行うための ROM に置かれたユーザー定義のルーチンである。リ
      セット初期化プログラムは、T-Monitor のリセット処理の最後に次の形式で呼び
      出される。

              void resetinit( void )


3. T-Monitor 実装仕様

本システムの T-Monitor は、必要最低限の機能に限定しており、デバッグ支援の機能
はデバッグコンソールの入出力と簡単なコマンド処理のみである。


3.1 コンソール

      T-Monitor のデバッグコンソール用シリアルポートとして、APBUART を使用する。
      このシリアルポートは、USBtoUART コンバーターを経由して、USB での接続とな
      る。

      通信仕様は以下の通り。

          通信速度        19,200 bps
          データ長        8 bit
          ストップビット  1 bit
          パリティ        なし
          フロー制御      なし

      通信速度は、ROM 情報の dbgport_bps の設定により変更できる。


3.2 T-Monitor のサービスコール

      レジスタの保存規則や引数の受け渡しは、C の関数呼び出し形式に準拠する。引
      数の最大数は 4 となる。

      %g2 に機能コードを設定して ta 16 により T-Monitor のサービスコールを呼び
      出す。

      サービスコールの実行中は全ての割り込みはマスクされる。また、スタックは呼
      び出した時点のスタックをそのまま使用する。

      %g2     機能コード
      %o0     第１引数
      %o1     第２引数
      %o2     第３引数
      %o3     第４引数
      ta      16
      %o0     戻り値

      機能コード
      0       Enter T-Monitor         モニタへ入る (*1)
      1       Get Character           コンソールから 1 文字入力
      2       Put Character           コンソールへ 1 文字出力
      3       Get Line                コンソールから 1 行入力
      4       Put String              コンソールへ文字列出力
      5       Execute Command         モニタコマンドの実行
      6       Read Disk               ディスクからの読み込み (未サポート)
      7       Write Disk              ディスクへの書き込み   (未サポート)
      8       Info Disk               ディスク情報の取り出し (未サポート)
      9       System Exit             システム終了 (*2)
      255     Extension SVC           拡張サービス機能

      (*1) コンソールにメッセージを表示して、コマンド入力待ちとなる。
      (*2) コンソールにメッセージを表示して、システム停止(無限ループ)する。


3.3 T-Monitor の拡張サービスコール

      tm_extsvc(INT fno, INT p1, INT p2, INT p3)

      以下の機能のみ対応する。

      fno                     機能
      -----------------------------------------------------------------
      0x00    デバッグポートの通信速度の取り出し
              p1〜p3:         未使用
              リターン値:     通信速度(bps)

      0x11    LED の点灯
              p1:             bit 0〜3  : LED[0..3] の点灯状態(0:OFF, 1:ON)
                              bit 16〜19: LED のマスク(0:設定しない, 1:設定する)
              p2〜p3:         未使用
              リターン値:     0: OK
              リターン値:     bit 0〜3  : LED の状態 (0: 0FF, 1: ON)
                              その他の bits: 0


3.4 T-Monitor のコマンド

      コードサイズの削減のため、以下の簡略化したコマンドにのみ対応する。

         d  [adr[ cnt]] - dump memory by byte (8 bits)
         db [adr[ cnt]] - dump memory by byte (8 bits)
         dh [adr[ cnt]] - dump memory by halfword (16 bits)
         dw [adr[ cnt]] - dump memory by word (32 bits)

         m  [adr[ dat]] - modify memory by byte (8 bits)
         mb [adr[ dat]] - modify memory by byte (8 bits)
         mh [adr[ dat]] - modify memory by halfword (16 bits)
         mw [adr[ dat]] - modify memory by word (32 bits)

         g  [adr]       - go/return
         e              - exit, system halt
         ?              - command help

      上記のコマンドは、以下の場合に利用できる。

      (1) "Enter T-Monitor" サービスコールを実行した場合

          デバッグコンソールに "TM> " のプロンプトを表示して、コマンド入力を受
          け付ける。"g" コマンドでサービスコールから戻る。

      (2) "Execute Command" サービスコールを実行した場合

          パラメータで指定したコマンドを 1 つのみ実行して、サービスコールから
          戻る。


4. T-Kernel 実装仕様

4.1 コンパイルオプション

      gcc のコンパイルオプションとして、下記のオプションを指定することを標準と
      する。
      なお、全てのソースを同じコンパイルオプションでコンパイルする必要がある。
      また、リンク時にも同じオプションの指定が必要である。

        -mcpu=leon3   Generate SPARC V8 code


4.2 システム状態判定

  (1) タスク独立部 (例外・割込ハンドラ、タイムイベントハンドラ)

      システム共有情報(SysCommonInfo)内のフラグ taskindp を使用して判定する。

      taskindp = 0    タスク部
      taskindp > 0    タスク独立部

      このフラグの設定は、T-Kernel によって行われる。

  (2) 準タスク部 (拡張 SVC ハンドラ)

      T-Kernel 内にソフトウエア的なフラグを設けて判定する。

  (3) ディスパッチ禁止

      PSR レジスタの PIL によって行う。

      PIL = 0         ディスパッチ許可
      PIL > 0         ディスパッチ禁止


4.3 T-Kernel で使用する例外・割込

      ソフトウェアトラップ(ta 命令)
      ・ T-Kernel システムコール・拡張 SVC    trap 17
      ・ デバッガサポート機能                 trap 18
      ・ タスク例外からの復帰                 trap 19

      例外
      ・FPU 無効 (fp_disabled)                tt 0x04
        浮動小数点コプロセッサ(FPU)のコンテキストスイッチに使用

      割込
      ・ソフトウェア割込                      irq 1 (tt 0x11)
      ・OS タイマ GPTIMER[0]                  irq 8 (tt 0x18)
        これらの割込は T-Kernel で占有するため、同じ割込ラインを他のデバイスに
        割り当てることはできない。(共有割込は不可)

           ※ tt = トラップタイプ
              trap = tt - 0x80
              irq = 割込ソース番号


4.4 システムコール

      呼び出し側は、C 言語の関数の呼び出し形式で、インターフェースライブラリを
      呼び出す。インターフェースライブラリは、下記のようになる。

      アセンブラから呼び出す場合も、C 言語と同様に関数形式によりインターフェー
      スライブラリを経由して呼び出すこととするが、下記のインターフェースライブ
      ラリ相当のことを行い、直接 ta 命令で呼び出してもよい。
      レジスタの保存規則は C 言語の規則にしたがうので、アセンブラから呼び出す
      場合も C 言語の規則にしたがってレジスタの保存を行う必要がある。

  (1) T-Kernel/OS システムコール

      ER tk_xxx_yyy(p1, p2, p3, p4, p5)

      引数は整数またはポインタで、C 言語の関数の引数渡しと同じ形式。

              //      %o0 =   p1
              //      %o1 =   p2
              //      %o2 =   p3
              //      %o3 =   p4
              //      %o4 =   p5
      tk_xxx_yyy:
              set     機能コード, %g2
              ta      17
              retl
              nop

  (2) 拡張 SVC

      INT zxxx_yyy( .... )

      引数は呼出側でパケット化し、パケットの先頭アドレスを %o0 レジスタに設定
      する。

      zxxx_yyy:
              st      %o0, [%sp+17*4] // レジスタ上の引数をスタックに積みパケ
      ット化
              st      %o1, [%sp+18*4]
              st      %o2, [%sp+19*4]
              st      %o3, [%sp+20*4]
              st      %o4, [%sp+21*4]
              st      %o5, [%sp+22*4]
              add     %sp, 17*4, %o0  // %o0 = 引数パケットのアドレス
              set     機能コード, %g2
              ta      17
              retl
              nop

      ここに示した引数のパケット化の方法は例である。引数の型や数に合わせてパケ
      ットを作成する必要がある。

  (3) T-Kernel/DS サービスコール

      ER td_xxx_yyy(p1, p2, p3, p4)

      引数は４個以下の整数またはポインタで、C 言語の関数の引数渡しと同じ形式。

              //      %o0 =   p1
              //      %o1 =   p2
              //      %o2 =   p3
              //      %o3 =   p4
      td_xxx_yyy:
              set     機能コード, %g2
              ta      18
              retl
              nop


4.5 FPU の使用

  (1) サブシステム

      拡張 SVC ハンドラおよびブレーク関数/スタートアップ関数/クリーンアップ関
      数/イベント処理関数では、これらが実行されるタスクのコンテキストに依存し
      て FPU の使用の可否が決まる。したがって、FPU の使用の可否は不確定である
      ため、一般に FPU は使用できないものとして考えなければならず、FPU は使用
      してはいけない。
      ただし、拡張 SVC は FPU が使用できる場合のみ呼出可能と(その拡張 SVC の仕
      様として)制限することで、拡張 SVC ハンドラでの FPU の使用は可能である。
      拡張 SVC ハンドラで FPU を使用する場合、C 言語の仕様にしたがって FPU レ
      ジスタを使用しなければならない。OS では FPU レジスタの保存等は行わない。
      なお、ブレーク関数/スタートアップ関数/クリーンアップ関数/イベント処理関
      数は、呼び出すタスクを制限することが難しいため、FPU を使用可能なタスクか
      らのみ呼び出すようにすることは難しい。したがって、これらの関数では FPU
      を使用してはならない。

  (2) タイムイベントハンドラ

      タイムイベントハンドラでは、FPU のレジスタは保存されていない。
      FPU を使用する場合は、ハンドラで独自に FPU レジスタを保存しなければなら
      ない。
      また、ハンドラから復帰する時には元に戻しておく必要がある。

  (3) 割込ハンドラ

      割込ハンドラでは、TA_HLNG 属性を指定した場合であっても FPU のレジスタは
      保存されていない。
      FPU を使用する場合は、ハンドラで独自に FPU レジスタを保存しなければなら
      ない。
      また、ハンドラから復帰する時には元に戻しておく必要がある。


4.6 例外・割込ハンドラ

      ER tk_def_int( UINT dintno, T_DINT *pk_dint )

      typedef struct t_dint {
              ATR     intatr;         /* 割込ハンドラ属性 */
              FP      inthdr;         /* 割込ハンドラアドレス */
      } T_DINT;

      BCC の Interrupt API によりハンドラを設定する。

      intatr := TA_HLNG               (TA_ASM には対応しておらず、指定不可)

      dintno := 割込ソース番号(irq)   1〜31

      T-Kernel ではデバイスに対する処理は何も行わない。割込のクリア等は、割込
      ハンドラが処理しなければならない。

  (1) TA_HLNG の場合

      BCC の Interrupt API により割込ハンドラを設定する。

    ・多重割込の許可・禁止は、BCC の Interrupt API により指定可能。
      具体的な使用方法などは、BCC のマニュアルを参照のこと。

    ・ノンマスカブル割込のハンドラを定義することはできない。定義した場合の動作
      は保証されない。
      通常、irq=15 がノンマスカブル割込である。

      割込ハンドラは、次の形式となる。

      void inthdr( UINT dintno )

      dintno  発生した割込に対応する割込ソース番号(irq)

    ・割込ハンドラに入ったときの CPU の状態は次のようになる。

              PSR レジスタ
                ET  = 1       トラップ許可
                S   = 1       スーパーバイザーモード
                PIL = 15      割込許可レベル(割込禁止)

      デフォルトでは多重割込は禁止されており、PIL=15 となる。
      BCC の Interrupt API の設定により多重割込が許可されている場合は、その指
      定に従い PIL が設定される。その場合、PIL=15 とはならない。

    ・割込ハンドラからの復帰は、関数からの return で行う。


  (2) BCC API

      tk_def_int() を使用せず、BCC の Trap API、Interrupt API を直接使用してハ
      ンドラを定義してもよい。
      この場合、T-Kernel (高級言語対応ルーチン)を経由しないため、次のような点
      に注意する必要がある。

    ・T-Kernel を経由しないため、タスク独立部判定のためのフラグが更新されない。
      そのため、タスク独立部として判定されないので、次のような点に注意が必要で
      ある。

      ・割込を許可(PSR.ET=1 PIL=0)すると、タスクディスパッチが発生する可能性が
        ある。
      ・システムコールを呼び出した場合、タスク部から呼び出したものとして処理さ
        れる。

      したがって、ハンドラ内でシステムコールを発行する必要がある場合は、必要に
      応じてタスク独立部判定フラグを設定しなければならない。

      タスク独立部判定フラグの設定は、システム共有情報内の taskindp フラグを操
      作することで行う。ただし、割込禁止状態(PSR.PIL > 0)で行わなければならな
      い。また、割込ハンドラを終了する前にフラグを必ず戻さなければならない。

              taskindp++;     /* タスク独立部に入る */

              taskindp--;     /* タスク独立部を出る */

      タスク独立部実行中は、割込許可(PSR.ET=1 PIL=0)してはいけない。
      多重割込の場合などもあるため、taskindp は必ずインクリメント／デクリメン
      トによって設定する必要がある。taskindp = 0 のような設定を行ってはいけな
      い。

    ・tk_ret_int() システムコールは提供されない。
      ハンドラからの通常の復帰処理により、tk_ret_int() 相当の処理となり、遅延
      ディスパッチが行われる。
      ただし、正しく遅延ディスパッチが行われるためには、ハンドラ実行中は PSR.
      PIL=0 に設定してはならない。ハンドラからの復帰時に PSR.PIL=0 となるよう
      にする必要がある。


4.7 タスク

      ER tk_cre_tsk( T_CTSK *ctsk )

      typedef struct t_ctsk {
              VP      exinf;          /* 拡張情報 */
              ATR     tskatr;         /* タスク属性 */
              FP      task;           /* タスク起動アドレス */
              PRI     itskpri;        /* タスク起動時優先度 */
              INT     stksz;          /* ユーザスタックサイズ(バイト) */
              INT     sstksz;         /* システムスタックサイズ(バイト) */
              VP      stkptr;         /* ユーザースタックポインタ */
              VP      uatb;           /* タスク固有空間ページテーブル */
              INT     lsid;           /* 論理空間ID */
              ID      resid;          /* リソースID */
              UB      dsname[8];      /* タスク名称 (DS用) */
      } T_CTSK;

  (1) オプション指定

      tskatr := (TA_ASM ‖ TA_HLNG)
              | [TA_SSTKSZ] | [TA_USERSTACK] | [TA_TASKSPACE] | [TA_RESID]
              | (TA_RNG0 ‖ TA_RNG1 ‖ TA_RNG2 ‖ TA_RNG3)
              | [TA_FPU]
              | [TA_DSNAME]

    ・保護レベルの指定(TA_RNGn)により、プロセッサモード(PSR.S)が設定される。
      TA_RNG3 のときユーザーモード(PSR.S=0)、TA_RNG0〜TA_RNG2 のときスーパーバ
      イザーモード(PSR.S=1)となる。
      独立したユーザースタックはなく、保護レベルの指定にかかわらず、常にシステ
      ムスタックと統合された一本のスタックとなる。

    ・TA_USERSTACK 指定は使用できない。E_NOSPT となる。

    ・lsid と uatb は特別な意味を持たず使用されないが、値は保持される。

    ・TA_COP0 が FPU に割り当てられる。他(TA_COP1〜3)は使用しない。TA_FPU =
      TA_COP0 となる。
      TA_FPU を指定した場合、FPU のコンテキスト(レジスタ)を待避するための領域
      (34*4 バイト)をスタックから割り当てる。

  (2) タスクの形式

      タスクは次の形式で、TA_HLNG, TA_ASM のどちらを指定しても同じで違いはない。

      void task( INT stacd, VP exinf )

      タスク起動時のレジスタの状態は下記のようになる。

      PSR
        S   = 0 or 1  プロセッサモード (TA_RNGn の指定による)
        ET  = 1       トラップ許可
        PIL = 0       割込許可レベル(割込許可)
        CWP = 1       カレントレジスタウインドウ

      WIM = 0x00000004

      FSR
        RD  = 0       近傍値に丸める
        TEM = 0       浮動小数点演算例外禁止
        NS  = 0       非標準演算禁止

      %o0 = stacd     タスク起動パラメータ
      %o1 = exinf     タスク拡張情報
      %fp = スタック領域の先頭(最上位)アドレス
      %sp = %fp - (16+1+6+1)*4

      その他のレジスタは不定である。
      また、%fp〜%sp の間のスタック領域(スタックフレーム)の内容も不定である。

      タスクの終了は、tk_ext_tsk() または tk_exd_tsk() を用いなければならない。
      単に return してもタスクの終了とはならない。return した場合の動作は保証
      されない。


4.8 タスクのレジスタの設定／参照

      ER tk_set_reg( ID tskid, T_REGS *regs, T_EIT *eit, T_CREGS *cregs )
      ER tk_get_reg( ID tskid, T_REGS *regs, T_EIT *eit, T_CREGS *cregs )

      typedef struct t_regs {
              VW      g1,g2,g3,g4,g5,g6,g7;           /* %g */
              VW      o0,o1,o2,o3,o4,o5,o7;           /* %o */
              VW      l0,l1,l2,l3,l4,l5,l6,l7;        /* %l */
              VW      i0,i1,i2,i3,i4,i5,i6,i7;        /* %i */
              VW      y;              /* multiply/divide */
      } T_REGS;

      typedef struct t_eit {
              VP      pc;             /* program counter */
              VP      npc;            /* next program counter */
              UW      psr;            /* processor state */
      } T_EIT;

      typedef struct t_cregs {
              VP      sp;             /* %o6 */
      } T_CREGS;

    ・PSR レジスタは、icc(integer condition codes) 以外のビットは変更できない。
      変更は無視される。

    ・DORMANT 状態のタスクに対してレジスタの設定を行ったとき、%o0, %o1 レジス
      タは tk_sta_tsk() によってタスク起動パラメータ／拡張情報が設定されるため、
      tk_set_reg() で設定した値は捨てられることになる。

    ・T_REGS, T_EIT, T_CREGS に含まれるレジスタが、タスクのコンテキストに含ま
      れるレジスタとなる。ここに含まれないレジスタは、タスクのコンテキストには
      含まれない。

  (1) コプロセッサのレジスタの設定／参照

      ER tk_set_cpr( ID tskid, INT copno, T_COPREG *copreg )
      ER tk_get_cpr( ID tskid, INT copno, T_COPREG *copreg )

      typedef struct t_cop0regs {
              UW      f[32];          /* f0〜f31 */
              UW      fsr;            /* floating-point state */
      } T_COP0REGS;

      typedef union {
              T_COP0REGS      cop0;   /* FPU */
      #if 0
              T_COP1REGS      cop1;   /* なし */
              T_COP2REGS      cop2;   /* なし */
              T_COP3REGS      cop3;   /* なし */
      #endif
      } T_COPREGS;

      copno = 0 で、FPU のレジスタの参照/設定が可能。copno = 1〜3 は E_PAR と
      なる。TA_FPU を指定していないタスクでは、copno = 0 でも E_PAR となる。


4.9 タスク例外ハンドラ

      タスク例外ハンドラは、レジスタの保存・復帰を行う専用のエントリールーチン
      を持つ必要がある。エントリールーチンには、マクロ TEXHDR_ENTRY を使用する。
      または、これに相当する処理を独自に行ってもよい。

      タスク例外ハンドラ(エントリールーチン)に入るときのスタックの状態
      関数のスタックフレームの形式に準じている。そのため、word 数に満たない分
      はパディングを挿入する。

              +---------------+
      sp ->   | 保存領域      | レジスタウィンドウ保存領域と隠しパラメータ
              |     (17 word) | 保存するレジスタ %i# %l#
              +---------------+
        +17*4 | texcd         | 例外コード
              |      (6 word) |
              +---------------+
        +23*4 | psr           | ハンドラからの戻り時に復帰する PSR
              | pc            | ハンドラからの戻り先 PC
              | npc           | ハンドラからの戻り先 nPC
              |      (3 word) |
              +---------------+
        +26*4 | 保存領域      | タスク例外ハンドラで使用するレジスタ保存領域
              |     (42 word) | 保存するレジスタ %y %g# %f# %fsr
              +---------------+
      fp ->   |               |

      アセンブラのマクロは、ヘッダファイル include/tk/asm.inc に用意されている。


4.10 システムコール・拡張 SVC 呼び出し元情報

      td_hok_svc() によるフックルーチンに渡される、システムコール・拡張 SVC 呼
      び出し元情報の形式は次のようになる。

      typedef struct td_calinf {
              VP      sp;     /* スタックポインタ */
              VP      o7;     /* 呼出元命令のアドレス */
              VP      pc;     /* トラップ発生アドレス */
              VP      npc;    /* トラップ戻りアドレス */
      } TD_CALINF;

      sp は、システムコール呼出時点のスタックフレームの位置を示している。
      o7 は、システムコール呼出時点の %o7 レジスタの値である。
      pc と npc は、トラップにより保存されたプログラムカウンタである。

      システムコール・拡張 SVC からの戻り番地は npc である。しかし、通常はイン
      ターフェースライブラリを利用して呼び出すため、npc はインターフェースライ
      ブラリの番地を指している。
      標準のインターフェースライブラリを使用している場合は、インターフェースラ
      イブラリからの戻り番地は o7 となる。


4.11 システムメモリ管理およびアドレス空間管理

  (1) システムメモリプール

      システム共有情報の ramtop 〜 ramend で指定された領域をシステムメモリプー
      ルとして使用し、動的メモリを割り当てる。

  (2) システムメモリの割り当て

      tk_get_smb() の属性指定(attr) [ TA_NORESIDENT, TA_NOCHAE, TA_RNG0〜3 ]
      は無視される。
      メモリのブロックサイズは、1 KB である。

  (3) メモリプールの生成

      tk_cre_mpf(), tk_cre_mpl() の属性指定(attr) [ TA_RNG0〜3 ] は無視される。

  (4) メモリ獲得/解放ライブラリ

      Kmalloc(), Kcalloc(), Krealloc(), Kfree()
      Vmalloc(), Vcalloc(), Vrealloc(), Vfree()
      Smalloc(), Scalloc(), Srealloc(), Sfree()

      これら(K〜, V〜, S〜)の区別はない。すべて同じとなる。

      malloc(), calloc(), realloc(), free() は、BCC のライブラリで提供される。
      そのため、これらは T-Kernel の管理外となる。

  (5) アドレス空間の操作

      アドレス空間チェックは常にアクセス許可となる。
      アドレス空間のロック/アンロックは意味を持たない。

  (6) 物理アドレスの取得

      アドレスは常に物理アドレスのため、 CnvPhysicalAddr() は何も行わない。

  (7) メモリのマップ

      MapMemory() の属性指定(attr) [ MM_USER, MM_SYSTEM, MM_READ, MM_WRITE,
      MM_EXECUTE, MM_CDIS ] は無視される。


4.12 CPU 割込制御

      以下の CPU 割込制御マクロ関数は、PSR レジスタの割込許可レベル(PIL)を 15
      に設定することにより割込を禁止し、元の値に戻すことにより許可する。

      DI( UINT intsts )       割込禁止 (以前の状態を intsts に保存)
      EI( UINT intsts )       割込許可 (intsts で指定した状態へ復帰)
      isDI( UNIT intsts )     intsts が割込禁止状態のとき TRUE


4.13 割込コントローラ

      割込コントローラの操作に関しては、下記のライブラリ関数がある。

  (1) 割込ベクター(INTVEC)の値

      割込コントローラの操作関数で intvec として指定する値は、割込ソース番号
      (irq=1〜31)となる。
      有効範囲外またはハードウェア未実装の番号を指定した場合の動作は保証されな
      い。

  (2) 割込許可

      void EnableInt( INTVEC intvec )

      intvec で指定した割込を許可する。

      BCC の bcc_int_unmask(intvec) により割込を許可する。

  (3) 割込禁止

      void DisableInt( INTVEC intvec )

      intvec で指定した割込を禁止する。

      BCC の bcc_int_mask(intvec) により割込を禁止する。

  (4) 割込要求のクリア

      void ClearInt( INTVEC intvec )

      intvec で指定した割込の割込要求をクリアする。

      BCC の bcc_int_clear(intvec) により割込をクリアする。

  (5) 割込要求の有無の確認

      BOOL CheckInt( INTVEC intvec )

      intvec の割込要求があるか調べる。
      割込要求があれば TRUE (0 以外) を返す。

      割込コントローラの interrupt pending register (IPEND) を参照し、intvec
      に対応するビットがセットされているか調べる。


4.14 物理タイマ

      以下の 1 つの物理タイマに対応している。

      No Unit     Clock(Hz) Resolution(usec) Max counts (msec)  Handler IRQ
      -----------------------------------------------------------------------
      1  GPTIMER-2 1000000        1          0xFFFFFFFF(4294967) True    9


4.15 メモリキャッシュ制御機能

  (1) キャッシュモードの設定

      INT SetCacheMode( const void *addr, INT len, UINT mode )

      常に E_NOSPT を返す。

  (2) キャッシュの制御

      INT ControlCache( const void *addr, INT len, UINT mode )

      BCC の bcc_flush_cache() によりキャッシュをフラッシュする。
      指定されたアドレス範囲やモードに関係なく、キャッシュ全体のフラッシュとな
      る。


4.16 論理アドレス空間管理

      本システムでは論理アドレス空間は存在しないため、論理アドレス空間管理には
      対応していない。

  (1) アドレス空間情報の取得

      ER GetSpaceInfo( const void *addr, INT len, T_SPINFO *pk_spinfo )

      typedef struct {
              VP      paddr;  /* addr に対応する物理アドレス */
              VP      page;   /* addr が属するページの先頭物理アドレス */
              INT     pagesz; /* ページサイズ(バイト数) */
              INT     cachesz;/* キャッシュラインサイズ(バイト数) */
              INT     cont;   /* 物理アドレスの連続領域のサイズ(バイト数) */
      } T_SPINFO;

      取得した値は以下の通りとなる。
          paddr = addr
          page  = (addr / 1024) * 1024
          pagesz = 1024
          cachesz = 32
          cont = len

  (2) メモリアクセス権の設定

      INT SetMemoryAccess( const void *addr, INT len, UINT mode )

      常に E_NOSPT を返す。


以上
