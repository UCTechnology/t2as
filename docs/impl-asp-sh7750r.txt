/*
 *----------------------------------------------------------------------
 *    UCT T-Kernel 2.0 DevKit tuned for ASP-SH7750R
 *
 *    Copyright (c) 2013 UC Technology. All Rights Reserved.
 *----------------------------------------------------------------------
 *
 *    Version:   1.00.00
 *    Released by UC Technology (http://www.uctec.com/) at 2013/01/31.
 *    Changed by UC Technology (http://www.uctec.com/) at 2015/05/15.
 *
 *----------------------------------------------------------------------
 */


==============================================================================
        T-Kernel 2.0 ( ASP-SH7750R ) 実装仕様書
==============================================================================
                                                               Version 1.00.00

1. 概要

本書は、T-Monitor、T-Kernel に関する NE-87796 ボード (CPU SH7750R コア ASIC) 
(以降、ASP-SH7750R と記述) 固有の実装に関する仕様書である。

      ※ 本実装は「T-Kernel 2.0ソースコードパッケージ Ver 2.01.03」に含まれる
         T-Kernel ソースコード、および開発環境を使用している。

      ※ 本実装は開発環境としてルネサステクノロジー社製の SH 用統合開発環境
         HEW (High-performance Embedded Workshop) の使用を前提としてる。


2. 全体の実装仕様

2.1 バンク1レジスタ の割り当て

      バンク1のレジスタは以下のように使用する。

        R0    作業用                            タスク付属
        R1    予約                              タスク付属
        R2    動作モードレジスタ (MDR)          タスク付属
        R3    システムスタックトップ (SST)      タスク付属
        R4    作業用                            タスク独立
        R5    予約                              タスク独立
        R6    例外/割込スタックポインタ (ISP)   タスク独立
        R7    例外/割込作業用                   タスク独立

      タスク付属のレジスタは、タスクのコンテキストに含まれ、タスク毎に異なる値
      を持つ。

      タスク独立のレジスタは、タスクのコンテキストに含まれず、タスクが切り替わ
      った場合もレジスタの内容は変らない。

      R2 は、動作モードレジスタ（MDR)として、システムコールをどのレベルから呼
      び出したかをチェックするためなどに使用する。
      T-Monitor 起動時およびブート開始時に 0 に初期化される。

                       31     18 17 16 15      2 1   0
                      +---------+-----+---------+-----+
                      | 予約(0) | PPL | 予約(0) | CPL |
                      +---------+-----+---------+-----+
                      CPL     現在の保護レベル
                      PPL     一つ前の保護レベル

      R3 は、システムスタックトップ (SST) として、タスクごとのシステムスタック
      トップを保持するために使用する。

      R6 は、例外/割込スタックポインタ (ISP) として、例外/割込処理で使用するス
      タックポインタに使用する。T-Monitor 起動時およびブート開始時に例外/割込
      スタックの先頭に初期化される。

      R7 は例外/割込ハンドラ内で例外ブロック(SR.BL=1)状態のときに作業用レジス
      タとして使用する。このとき、レジスタの内容は保存しないため、例外ブロック
      解除(SR.BL=0)状態のときには、例外/割込の発生によって R7 が破壊される可
      能性が常にあるので、例外ブロック解除(SR.BL=0)状態のときには R7 は使用で
      きない。

2.2 メモリマップ

  (1) 全体

      論理アドレス                                  物理アドレス
      0x00000000 +===============================+
                 |        論理メモリ空間     (U0)|
                 |                               |
      0x04000000 |-------------------------------|-- 0x04000000
                 |     ユーザプログラム領域 (*2) |   [RAM 実装]
      0x04400000 |-------------------------------|-- 0x04400000
                 |                               |
                 |                               |
                 |                               |
      0x80000000 +===============================+
                 |        物理メモリ空間     (P1)|
                 |       (キャッシュオン)        |
      0x84000000 |-------------------------------|-- 0x04000000
                 |   システムプログラム領域 (*1) |   [RAM 実装]
      0x84400000 |-------------------------------|-- 0x04400000
                 |                               |
      0xa0000000 +===============================+
                 |        物理メモリ空間     (P2)|
                 |       (キャッシュオフ)        |
      0xa4000000 |-------------------------------|-- 0x04000000
                 |   [ システムプログラム領域 ]  |   [RAM 実装]
      0xa4400000 |-------------------------------|-- 0x04400000
                 |                               |
      0xc0000000 +===============================+
                 |       論理メモリ空間      (P3)|
                 |          (未使用)             |
      0xe0000000 +===============================+ 
                 |         内蔵I/O空間       (P4)|
                 |       (未使用領域含む)        |
      0xffffffff +===============================+

      ・ RAM は 4 Mバイト（0x0400000～0x043FFFFF）が実装されている。

      ・システムプログラムは物理メモリ空間の P1 領域(*1)で動作し、メモリ保護を
        行う場合のユーザプログラムは、論理メモリ空間の U0 領域（*2)で動作する。

      ・ユーザプログラム領域は、MMU によりシステムプログラム領域と同一の物理ア
        ドレス領域にマッピングされる。

      ・ P2 領域では、プログラムは実行しない。ただし、特殊操作のため、一時的に
         P1 領域のシステムプログラムが P2 領域で実行される場合がある、

      ・ P3 領域は使用しない。

  (2) システムプログラム領域 (P1領域)

      0x84000000 +-------------------------------+ <--- ベクタベース (VBR)
                 |     T-Monitor コード          |
                 |    コード/データ/スタック     |
                 |       (例外エントリ)          |
      0x84001000 +-------------------------------+
                 |    例外/割込ベクタテーブル    |
                 |    特殊ハンドラアドレス       |
      0x84001208 +-------------------------------+
                 |      システム共有情報         |
      0x84001280 +-------------------------------+
                 |      例外/割込スタック        |
      0x84001500 +-------------------------------+
                 |           ROM 情報            |
                 |      システム構成情報         |
                 |     (SYSCONF / DEVCONF)       |
      0x84002000 +-------------------------------+
                 |                               |
                 |  T-Kernel + アプリケーション  |
                 |        コード/データ          |
                 |                               |
                 +- - - - - - - - - - - - - - - -+ <-- ram_top
                 |      動的メモリ領域           |
                 |    ( T-Kernel 管理領域 )      |
                 +- - - - - - - - - - - - - - - -+ <-- ram_end
                 |                               |
                 |   ( T-Kernel 管理外領域 )     |
                 |                               |
      0x84400000 +-------------------------------+

      ・システム起動時に T-Monitor により次のように設定され、以後変更されない
        (変更してはならない)。

                VBAR = 0x84000000       ベクタベースアドレスレジスタ

      ・ram_top/ram_end はシステム起動時に T-Monitor がシステム共有情報に設定
        する。
        ram_top ～ ram_end の間は、T-Kernel が動的メモリ領域として管理する。

  (3) 例外/割込ベクタテーブル

      0x84001000 +-------------------------------+ ベクタ番号  割込番号
                 | パワーオン/H-UDIリセット      |    0x00      0x000
                 | マニュアルリセット            |    0x01      0x020
                 | TLB ミス/TLB 無効例外(読出)   |    0x02      0x040
                 | TLB ミス/TLB 無効例外(書込)   |    0x03      0x060
                 | 初期ページ書込み例外          |    0x04      0x080
                 | TLB 保護例外(読出)            |    0x05      0x0A0
                 | TLB 保護例外(書込)            |    0x06      0x0C0
                 | CPU アドレスエラー(読出)      |    0x07      0x0E0
                 | CPU アドレスエラー(書込)      |    0x08      0x100
                 | FPU 例外                      |    0x09      0x120
                 | 命令/データTLB 多重ヒット例外 |    0x0A      0x140
                 | 無条件トラップ(TRAPA 命令)    |    0x0B      0x160
                 | 一般不当命令例外              |    0x0C      0x180
                 | スロット不当命令例外          |    0x0D      0x1A0
                 | ノンマスカブル割込み(NMI)     |    0x0E      0x1C0
                 | ユーザブレークポイント        |    0x0F      0x1E0
      0x84001040 +-------------------------------+
                 | IRL 15 割込み                 |    0x10      0x200
                 |         ::                    |     ::         ::
                 | IRL 1  割込み                 |    0x1E      0x3C0
                 | 内蔵 I/O 割込み               |    0x1F      0x3E0
                 |         ::                    |     ::         ::
                 |         ::                    |    0x6F      0xDE0
      0x840011c0 +-------------------------------+
                 | TRAPA #0x70 命令              |    0x70      0xE00
                 |         ::                    |
                 |       #0x7F 命令              |    0x7F      0xFE0
      0x84001200 +-------------------------------+
                 | デフォールトハンドラ          |    0x80      0x1000
      0x84001204 +-------------------------------+
                 | TLB ミス例外ハンドラ          |    0x81      0x1020
      0x84001208 +-------------------------------+

      ・例外/割込ベクタテーブルには、例外/割込が発生した場合のハンドラのアド
        レスを登録する。これは、ハードウェアが規定するベクタアドレスではなく、
        例外/割込発生時に T-Monitor の例外/割込処理ルーチンが参照し、登録され
        ているハンドラにジャンプする。

      ・例外/割込ベクタテーブルは、T-Monitor により初期化され、以後、T-Kernel
        により、必要とする例外ベクタが設定される。

      ・デフォルトハンドラは、ハンドラが登録されていない例外/割込が発生した場
        合に呼び出されるハンドラ。NULL を未登録とする。

      ・TLB ミス例外に対しては、効率を重視するため、専用のハンドラとしている。

      ・ベクタ番号は、TRAPA 命令での番号を意味する。

      ・割込番号は、例外の場合は EXPEVT、割込みの場合は、INTEVT の値であり、
        tk_def_int() などでの割込定義番号(dintno)として使用する。

  (4) ユーザプログラム領域 (U0 領域)

      U0 領域アドレス                              P1 領域アドレス
      0x04000000 +-------------------------------+ 0x84000000
                 |                               |
                 |                               |
                 |        (アクセス不可)         | (システムプログラム)
                 |                               |
                 +-------------------------------+ <-- ram_top
                 |                               |
                 |        動的メモリ領域         |
                 |     (一部のみ読込/書込可)     |
                 |                               |
                 +-------------------------------+ <-- ram_end
      s_usr_code +-------------------------------+
                 |      ユーザプログラム         |
                 |        コード領域             |
                 |        (読込のみ可)           |
      e_usr_code +-------------------------------+
      s_usr_data +-------------------------------+
                 |      ユーザプログラム         |
                 |        データ領域             |
                 |       (読込/書込可)           |
      e_usr_data +-------------------------------+
                 |      (アクセス不可)           |
      0x04400000 +-------------------------------+ 0x84000000

      ・ユーザプログラム領域 (U0 領域)は、メモリ保護を行う場合にユーザプログラ
        ムを配置する領域であり、T-Kernel の管理外の領域となる。

      ・メモリ保護を行わない場合は、ユーザプログラムはシステムプログラムに含ま
        れるため、ユーザプログラム領域(U0 領域)は使用しない。

      ・s_usr_code ～ e_usr_code にユーザプログラムのコードを配置し、s_usr_data
        ～ e_usr_data にユーザプログラムのデータを配置する。これらのアドレスは
        ROM 情報に設定する。

      ・ユーザプログラムのスタック領域、および tk_get_smb() などで、動的に獲得
        したメモり領域は、動的メモリ領域に配置される。

      ・ユーザプログラムからは、U0 領域のコード領域、データ領域、および動的メ
        モリ領域の一部(スタック、および動的に獲得した領域)のみアクセス可能であ
        り、それ以外の領域をアクセスした場合は、メモリ保護違反例外が発生する。

2.3 ROM 情報

      ROM 情報は、起動時のブート処理の過程で設定される。(ブート処理については
      後述)

      ※ 本システムは、すべて RAM 上で動作するため、この ROM 情報という名称は
         正確ではないが、意味合いは同じため、この名称を使うものとする。

      typedef struct {
              FP      kernel;         /* T-Kernel 起動アドレス */
              UB      *sysconf;       /* SYSCONF 先頭 */
              UB      *devconf;       /* DEVCONF 先頭 */
              void    *userarea;      /* RAM ユーザエリア先頭 */
              FP      userinit;       /* ユーザ初期化プログラムアドレス */
              FP      resetinit;      /* リセット初期化プログラムアドレス */
              VW      rsv[10];        /* 予約 */
              UW      rd_type;        /* ROM ディスク種別 */
              UW      rd_blksz;       /* ROM ディスクブロックサイズ */
              UW      rd_saddr;       /* ROM ディスク開始アドレス */
              UW      rd_eaddr;       /* ROM ディスク終了アドレス */
              VW      rsv2[8];        /* 予約 */
              UW      s_usr_code;     /* ユーザコード領域開始アドレス */
              UW      e_usr_code;     /* ユーザコード領域終了アドレス */
              UW      s_usr_data;     /* ユーザデータ領域開始アドレス */
              UW      e_usr_data;     /* ユーザデータ領域終了アドレス */
      } RomInfo;

      kernel        T-Kernel の起動アドレスを指定する。
                    T-Monitor はこのアドレスへジャンプして OS を起動する。

      sysconf       SYSCONF を格納したアドレスを指定する。

      devconf       DEVCONF を格納したアドレスを指定する。

      userarea      RAM の内、T-Kernel の管理から外すユーザエリアの先頭アドレ
                    スを指定する。通常は RAM 領域の終端、またはユーザコード領
                    域開始アドレスを指定する。
                    このアドレスと実際に RAM が実装されている領域の終端(上位)
                    アドレスの内のいずれか下位側のアドレスが RAM_END となる。

      userinit      ユーザ作成の初期化プログラムのエントリアドレスを指定する。
                    T-Kernel 起動後、ここへ登録されたプログラムを実行する。
                    NULL を指定した場合は、ユーザ初期化プログラムは実行しない。
                    一般的にはユーザ初期化プログラムを使用する必要はないため、
                    NULL を指定する。

      resetinit     ユーザ作成のリセット初期化プログラムのエントリアドレスを指
                    定する。
                    リセット処理後、ここへ登録されたプログラムを実行する。
                    NULL を指定した場合は、リセット初期化プログラムは実行しな
                    い。
                    拡張ボードなどのハードウェア初期化処理が T-Kernel 起動以前
                    に必要な場合に指定する。

      rd_xxxx では、ROM 上に置かれた ROM ディスクに関する指定を行う。
      ROM ディスクが存在しないときは、すべて 0 とする。
      ※ 本システムでは、ROM ディスクは存在しないので、すべて 0 を設定する。

        rd_type       ディスクタイプ (1 : ROM ディスク (書き込み不可))
        rd_blksz      ディスクブロックサイズ (通常は 512)
        rd_saddr      ROM ディスク領域の開始アドレス
        rd_eaddr      ROM ディスク領域の終了アドレス(+1)

      x_usr_xxxx では、メモリ保護を行う場合のユーザアプリケーションプログラム
      を配置するアドレス領域を指定する。コード領域は読込みのみ許可、データ領域
      は、読込みと書込み両方とも許可される。
      設定するアドレスは、ページサイズ (4KB) 境界とすること。
      メモリ保護を使用しない場合は、すべて 0 を設定する。

        s_usr_code    ユーザコード領域の開始アドレスを指定する。
        e_usr_code    ユーザコード領域の終了アドレスを指定する。
        s_usr_data    ユーザデータ領域の開始アドレスを指定する。
        e_usr_data    ユーザデータ領域の終了アドレスを指定する。

2.4 システム共有情報

      typedef struct {
              VW      rsv[20];        /* 予約 */
              VW      osrsv[4];       /* OS 使用 */
              UB      *sysconf;       /* SYSCONF 先頭 */
              UB      *devconf;       /* DEVCONF 先頭 */
              VW      rsv2[1];        /* 予約 */
       (*1)   UH      Iclk;           /* CPU クロック周波数 (MHz) */
       (*1)   UH      Pclk;           /* 周辺クロック周波数 (MHz) */
       (*1)   void    *ramtop;        /* RAM 空き領域先頭 (RAM_TOP)  */
       (*1)   void    *ramend;        /* RAM 空き領域終端(+1) (RAM_END) */
      } SysCommonInfo;

      (*1) は、T-Monitor で設定する情報。

  (1) T-Monitor

      システム起動時およびブート開始時に、システム共有情報を初期化する。

        ramtop,ramend  RAM の空き領域の先頭と終端のアドレスを設定する。
                       ramend - ramtop が空き領域のサイズとなる。

        Iclk    CPU クロック周波数 (MHz)
        Pclk    周辺クロック周波数 (MHz)
                これらは、デバイスドライバ等が基準クロックを参照するために使用
                する。

      これら以外のシステム共有情報はすべて 0 クリアする。

  (2) T-Kernel 起動処理

      起動処理の最初に下記のように設定する。

        sysconf   ROM 情報から取得した SYSCONF の先頭アドレス
        devconf   ROM 情報から取得した DEVCONF の先頭アドレス
        ramtop    T-Kernel のデータ領域で消費した領域を除く RAM の先頭アドレス

2.5 スーパーバイザーコールの割り当て

      TRAPA #0x70       T-Monitor サービスコール              (T-Monitor)
      TRAPA #0x71       T-Kernel システムコール/拡張 SVC      (T-Kernel)
      TRAPA #0x72       tk_ret_int() システムコール           (T-Kernel)
      TRAPA #0x73       タスクディスパッチャ                  (T-Kernel)
      TRAPA #0x74       (予約)
      TRAPA #0x75       SR レジスタロード機能                 (T-Kernel)
      TRAPA #0x76       デバッガサポート機能                  (T-Kernel)
      TRAPA #0x77～0x7F (予約)

2.6 保護レベル

      保護レベル             プロセッサ動作モード
                     メモリ保護あり    メモリ保護なし
          0           特権モード        特権モード
          1           特権モード        特権モード
          2           ユーザモード      特権モード
          3           ユーザモード      特権モード

      メモリ保護なしのときは、保護レベル 0～3 はすべて特権モード（SR.MD=1) で
      動作する。
      メモリ保護ありのときは、保護レベル 2, 3 はユーザモード（SR.MD=0) で動作
      する。
      保護レベル 3 は、プロセス用のため、本システムでは使用しない。

2.７ スタック

  (1) ユーザスタック

      ユーザタスクを処理している状態で使われるスタック。
      保護レベル 1～3 のタスクでは、タスクごとに存在し、保護レベル 1 の場合は、
      P1 領域、保護レベル 2～3 の場合は、U0 領域に割り当てられる。
      保護レベル 0 のタスクでは存在せず、システムスタックがユーザスタックとし
      ても使われる。ユーザスタックは、SP (R15)レジスタに保持される。

  (2) システムスタック

      T-Kernelのシステムコールや拡張システムコールを処理している状態で使われる
      スタック。タスクごとに存在し、P1 領域に割り当てられる。
      保護レベル 1～3 のタスクでは、システムコールの処理のエントリ時にユーザス
      タックからシステムスタックに切り替えられ、戻り時にユーザスタックに戻され
      る。システムスタックトップは、SST (R3_BANK1)レジスタに保持される。

  (3) 例外/割込スタック

      例外/割込ハンドラを処理している状態で使われるスタック。
      システム全体で 1 つだけ存在し、常に ISP (R6_BANK1) レジスタに保持される。
      起動時に T-Monitor が P1 領域の固定的なメモリ領域 (メモリマップ参照) に
      割り当てる。

2.8 例外/割込ハンドラ

      例外/割込が発生すると、T-Monitor 内の処理ルーチンが起動され、例外/割込ベ
      クタテーブルを参照し、必要な設定を行った後、各ハンドラへジャンプする。

  (1) 例外 (VBR + 0x100)

      EXPEVT レジスタから例外コードを取得し、例外/割込ベクタテーブルのベクタ番
      号を求め、設定されているハンドラにジャンプする。

             ベクタ番号 = EXPEVT / 0x20

      ハンドラが未設定(NULL) の場合はデフォルトハンドラへジャンプする。

      ハンドラ呼び出し時のレジスタ
            R0_BANK1 = ベクタ番号 * 4 + 要因 (0:例外、1:TRAPA、2:割込み)
            R7_BANK1 = 不定
            SP(R15)  = システムスタックポインタ

      ハンドラ呼び出し時のプロセッサ状態
            SR.MD = 1   特権モード
            SR.RB = 1   レジスタバンク１
            SR.BL = 1   例外ブロック状態
            SR.I = 15   割込禁止

      ハンドラ呼び出し時のスタック (例外/割込スタック)
               +---------------+
        ISP -> | R0_BANK1      |
               | SPC           |
               | SSR           |
               | MDR(R2_BANK1) |
               +---------------+
               : USP(R15)      : システムスタックへの切替があった場合のみ
               +---------------+

                USP はユーザスタックポインタで、システムスタックへ切り替えた
                場合のみ保存される。

      TRAPA に対応するベクタテーブルには、TRAPA 例外ハンドラが設定されており、
      TRAPA 例外ハンドラにジャンプする。

  (2) TRAPA 例外ハンドラ

      TRA レジスタからトラップ番号を取得し、例外/割込ベクタテーブルのベクタ番
      号を求め、設定されているハンドラへジャンプする。

             ベクタ番号 = トラップ番号 = TRA / 4

      ただし、以下の場合は、デフォルトハンドラへジャンプする。

        ・トラップ番号が 0x80 以上の場合
        ・トラップ番号が 0x0B の場合
        ・ハンドラアドレスが NULL の場合

      ハンドラ呼び出し時の状態は、例外と同じで、R0_BANK1 の要因のみ異なる。

  (3) 割込 (VBR + 0x600)

      INTEVT レジスタから割込コードを取得し、例外/割込ベクタテーブルのベクタオ
      フセットを求め、設定されているハンドラにジャンプする。

             ベクタ番号 = EXPEVT / 0x20

      ハンドラが未設定(NULL) の場合はデフォルトハンドラへジャンプする。

      ハンドラ呼び出し時の状態は、例外と同じで、R0_BANK1 の要因のみ異なる。

  (4) TLB ミス例外 (VBR + 0x400)

      TLB ミス例外ハンドラベクタに設定されたハンドラへ直接ジャンプします。
      効率重視のため、スタックへのレジスタの退避は行わない。

      ハンドラが未設定(NULL) の場合はデフォルトハンドラへジャンプする。
      メモリ保護を行う場合は、TLB ミス例外ハンドラは必須となる。

      ハンドラ呼び出し時のレジスタ
            R7_BANK1 = 不定

      ハンドラ呼び出し時のプロセッサ状態
            SR.MD = 1   特権モード
            SR.RB = 1   レジスタバンク１
            SR.BL = 1   例外ブロック状態

      ハンドラ呼び出し時のスタック (例外/割込スタック)
            レジスタの退避は行われない。

2.9 システムコール

      レジスタの保存規則や引数の受け渡しは、開発環境(HEW)の C の関数呼び出し
      の形式に準拠する。
      C 言語における、基本的なレジスタの割り当て規則は次の通り。

      R0～R7, MACH, MACL  テンポラリレジスタ
      R8～R15, PR         パーマネントレジスタ
      R14                 フレームポインタ
      R15                 スタックポインタ
      GBR                 未使用

      引数      R4～R7    第1 ～ 第4 の 32 ビット引数(long long 型を除く)
                スタック  long long 型引数、および 第5 引数以降
      戻り値    R0

      テンポラリレジスタは関数の呼び出しによって破壊される。それ以外のレジスタ
      は保存される。

  (1) T-Monitor サービスコール

      R0      機能コード
      R4      第1 引数
      R5      第2 引数
      R6      第3 引数
      R7      第4 引数
      TRAPA   #H'70
      R0      戻り値

      引数の最大数は 4 で、long long 型引数は使用しないため、引数はスタックには
      積まれない。
      上記のようにレジスタに引数と機能コードを設定して、TRAPA #H'70 により呼び
      出す。

  (2) T-Kernel/OS, T-Kernel/DS システムコール

      R0     機能コード (< 0)
      R4     第1 引数 (long long 型引数を除く)
      R5     第2 引数 (long long 型引数を除く)
      R6     第3 引数 (long long 型引数を除く)
      R7     第4 引数 (long long 型引数を除く)
             long long 型引数、および第5 引数以降はスタック
                      +-----------------+
                SP -> |long long 型引数 |
                      |第5 引数         |
                      +-----------------+
      TRAPA  #H'71
      R0     戻り値

      long long 型の引数を除いた、第4 引数まではレジスタに設定し、long long 型
      の引数、および第5 引数以降は順にスタックに積んで、TRAPA #H'71 により呼び
      出す。
      スタックに積まれた引数は、T-Kernel 内のシステムコールエントリールーチン
      でシステムスタックへコピーされる。

      T-Kernel/DS のシステムコールも同様だが、TRAPA #H'76 を使用する。

  (3) 拡張 SVC

      R0     機能コード (≧0)
      R4     引数パケットへのポインタ
      TRAPA  #H'71
      R0     戻り値

      引数はすべてパケット化し、パケットの先頭アドレスを R4 レジスタに設定して
      TRAPA  #H'71 により呼び出す。
      パケットは通常スタックに作成するが、他の場所でもよい。引数はパケット化す
      るため、数や型に制限はない。

      開発環境(HEW)の C の関数呼び出し形式により、long long 型引数、および 第5
      引数以降は、スタックに積まれることを、パケット化に際して考慮する必要があ
      る。long long 型引数を含む場合、効率よくパケット化を行うために、パケット
      内の引数の順番を変更する場合もある。

2.10 ブート

      システムの起動は、T-Monitor により次のような流れで行われる。

      ・システムの起動に必要なハードウエアを初期化する。
      ・例外/割込ベクタテーブルおよびシステム共有情報を初期化する。
      ・ROM 情報の kernel に指定された T-Kernel 起動アドレスへジャンプする。

  (1) 例外/割込ベクタテーブルの設定

      以下のベクタを T-Monitor 自身が処理するように設定する。これら以外は、
      デフォルトハンドラが起動されるように NULL に設定する。

      ベクタ番号
          0x00   デフォルトハンドラ
          0x01   デフォルトハンドラ
          0x0B   TRAPA 例外ハンドラ
          0x0E   デフォルトハンドラ
          0x0F   デフォルトハンドラ
          0x70   T-Monitor サービスコール (TRAPA #H'70)
          0x80   デフォルトハンドラ

      T-Monitor内のデフォルトハンドラでは、例外情報を表示して、システムを停止
      する。

  (2) T-Kernel の起動

      ROM 情報の kernel に格納された T-Kernel 起動アドレスを参照し、そのアドレ
      スへジャンプする。

      T-Kernel へ制御を移すときのプロセッサの状態は次の通り。

            SR.MD  = 1          特権モード
            SR.RB  = 0          レジスタバンク 0
            SR.BL  = 0          ブロックしない
            SR.FD  = 0          FPU 使用許可
            SR.I   = 15         割込禁止
            SP (R15)            モニタスタック
            SST (R3_BANK1)      モニタスタック
            ISP (R6_BANK1)      例外/割込スタック
            MDR (R2_BANK1)      0  (CPL=0, PPL=0)
            その他の汎用レジスタは不定

            キャッシュメモリ (ハードリセット状態のまま)
                ・キャッシュはオフ(CCR レジスタ= 0)
                ・キャッシュの内容はすべて無効状態

      スタックポインタ SP(R15) は、T-Monitor のスタック領域(モニタスタック)を
      指している。T-Kernel の 起動処理中は、このモニタスタックが使用される。
      使用可能なモニタスタックのサイズは 400 バイト以内とする。

2.11 ユーザ初期化プログラム

      ユーザ初期化プログラムは、ユーザ作成のプログラムなどを起動/終了する
      ための ユーザ定義のルーチンである。ユーザ初期化プログラムは、初期起動タ
      スクから次の形式で呼び出される。

              INT  userinit( INT ac, UB **av )

              ac      = 0     起動時呼出
                      = -1    終了時呼出

              戻り値   1      usermain を起動
                       0      システム終了(電源オフ)
                      -1      リセット(再起動)

      システム起動時に ac = 0 で呼び出され、システム終了時に ac = -1 で呼び
      出される。終了時の呼出(ac = -1)では、戻り値は無視される。
      処理の概略は次のようになる。

                fin = userinit(0, NULL);
                if ( fin > 0 ){
                        fin = usermain();
                }
                userinit(-1, NULL);

      ユーザ初期化プログラムは、初期起動タスクのコンテキストで実行される。
      ユーザ初期化プログラムでのスタックの消費は 4 KB 以内とする。

      ユーザプログラムの起動処理を行った後は、2種類の選択がある。
        (A) ユーザプログラムが終了するまで待った後、userinit() からリターン
            する。
        (B) ユーザプログラムの終了を待たずに userinit() からリターンする。

      いずれの場合も、userinit() からの戻り値によって、その後の処理を選択でき
      る。

2.12 リセット初期化プログラム

      リセット初期化プログラムは、拡張ボードなどのハードウェアの初期化処理を
      リセット直後に行うためのユーザ定義のルーチンである。リセット初期化プログ
      ラムは、T-Monitor のリセット処理の最後に次の形式で呼び出される。

              void resetinit( void )

      リセット初期化プログラムでのスタックの消費は 400 バイト以内とする。

2.13 例外/割込ハンドラのエントリールーチン

      ソースプログラム中の以下のファイルを参照のこと。

              /monitor/src/asp_sh7750r/eitent.S
              include/tk/sysdef.h (.inc)
                 --> include/tk/sysdepend/asp_sh7750r/sysdef_depend.h (.inc)
              include/tk/asm.h (.inc)
                 --> include/tk/sysdepend/asp_sh7750r/asm_depend.h (.inc)


3. T-Monitor 実装仕様

3.1 コンソール

      T-Monitor のコンソールとして使用するシリアルポートは、SCIF を使用する。
      通信仕様は以下の通りとする。

              通信速度        115,200 bps
              データ長        8 bit
              ストップビット  1 bit
              パリティ        なし
              フロー制御      なし

3.2 T-Monitor のサービスコール

      レジスタの保存規則や引数の受け渡しは、C の関数呼び出し形式に準拠する。引
      数の最大数は 4 となる。

      R0 に機能コードを設定して TRAPA #H'70 により T-Monitor のサービスコールを
      呼び出す。

      サービスコールの実行中は全ての割込みはマスクされる。また、スタックは
      T-Monitor 内の専用スタック領域を使用する。

      機能コード
      0       Enter T-Monitor         モニタへ入る (*1)
      1       Get Character           コンソールから 1 文字入力
      2       Put Character           コンソールへ 1 文字出力
      3       Get Line                コンソールから 1 行入力
      4       Put String              コンソールへ文字列出力
      5       Execute Command         モニタコマンドの実行     (未サポート)
      6       Read Disk               ディスクの読み込み       (未サポート)
      7       Write Disk              ディスクの書き込み       (未サポート)
      8       Info Disk               ディスクの情報取得       (未サポート)
      9       System Exit             システム終了 (*1)
      255     Extension SVC           拡張サービス機能

      (*1) コンソールにメッセージを表示して、無限ループに入る。

3.3 T-Monitor の拡張サービスコール

      tm_extsvc(INT fno, INT p1, INT p2, INT p3)

      fno                     機能
      -----------------------------------------------------------------
      0x00    デバッグポートの通信速度の取り出し
              p1～p3:         未使用
              リターン値:     115200


4. T-Kernel 実装仕様

4.1 システム状態判定

  (1) タスク独立部 (例外/割込ハンドラ、アラーム/周期ハンドラ)

      割込スタックポインタ(ISP = R6_BANK1)により判定し、割込スタックが消費され
      ていれば、タスク独立部とする。
      ISP の値は、T-Kernel 起動時に割込スタックトップ(istktop)に設定されており
      
          ISP < istktop

            ISP     例外スタックポインタ(現在位置)
            istktop 例外スタックポインタの初期値(0x84001500)

      のとき、タスク独立部とする。

  (2) 準タスク部 (拡張 SVC ハンドラ)

      T-Kernel 内にソフトウエア的なフラグを設けて判定する。

  (3) ディスパッチ禁止

      T-Kernel 内にソフトウエア的なフラグを設けて判定する。

4.2 T-Kernel で使用する例外/割込

      TRAPA 命令
        ・システムコール、拡張 SVC      TRAPA #0x71
        ・tk_ret_int() システムコール   TRAPA #0x72
        ・タスクディスパッチャ呼び出し  TRAPA #0x73
        ・SR レジスタロード機能         TRAPA #0x75
        ・デバッガサポート機能          TRAPA #0x76

      例外
        ・一般 FPU 抑止例外             ベクタ番号 0x40
        ・スロット FPU 抑止例外         ベクタ番号 0x41
                FPU は常に使用許可として動作するため、この例外が発生した場合は
                FPU 使用許可に設定する。(通常は発生しないはずであるが安全対策)

      割込
        ・タイマ1割込み   TMU0          ベクタ番号 0x20
                システムタイマとして使用

4.3 FPU の使用

  (1) タスク

      TA_FPU 属性の指定付きで生成されたタスクでのみ FPU が使用できる。
      TA_FPU 属性の指定無しで生成されたタスクでは FPU を使用してはならない。
      ( FPUレジスタの保存/復帰が行われない )

      TA_FPU 属性の指定付きで生成したタスクへのコンテキストスイッチの際に FPU
      レジスタの保存/復帰を行う。そのため明らかに FPU を使用しないタスクには、
      TA_FPU 属性を指定しないことが望ましい。

  (2) サブシステム

      拡張 SVC ハンドラおよびブレーク関数/スタートアップ関数/クリーンアップ関
      数/イベント処理関数では、これらが実行されるタスクのコンテキストに依存し
      て FPU の使用の可否が決まる。したがって、FPU の使用の可否は不確定である
      ため、一般に FPU は使用できないものとして考えなければならず、FPU は使用
      してはいけない。

      ただし、拡張 SVC は FPU が使用できる場合のみ呼び出し可能と(その拡張 SVC
      の仕様として)制限することで、拡張 SVC ハンドラでの FPU の使用は可能であ
      る。
      拡張 SVC ハンドラで FPU を使用する場合、C 言語の仕様にしたがって FPU レ
      ジスタを使用しなければならない。T-Kernel では FPU レジスタの保存等は行わ
      ない。

      なお、ブレーク関数/スタートアップ関数/クリーンアップ関数/イベント処理関
      数は、呼び出すタスクを制限することが難しいため、FPU を使用可能なタスクか
      らのみ呼び出すようにすることは難しい。したがって、これらの関数では FPU
      を使用してはならない。

  (3) アラーム/周期ハンドラ

      アラーム/周期ハンドラでは、FPU のレジスタは保存されない。
      FPU を使用する場合は、ハンドラで独自に FPU レジスタを保存しなければなら
      ない。また、ハンドラから復帰する時には元に戻しておく必要がある。

  (4) 割込ハンドラ

      割込ハンドラでは、TA_HLNG 属性を指定した場合であっても FPU のレジスタは
      保存されない。
      FPU を使用する場合は、ハンドラで独自に FPU レジスタを保存しなければなら
      ない。また、ハンドラから復帰する時には元に戻しておく必要がある。

4.4 例外/割込ハンドラ

      ER tk_def_int( UINT dintno, T_DINT *pk_dint )

      typedef struct t_dint {
              ATR     intatr;         /* 割込ハンドラ属性 */
              FP      inthdr;         /* 割込ハンドラアドレス */
      } T_DINT;

      dintno には、例外/割込ベクタテーブルの割込番号(0～0x1020) (ベクタ番号 *
      0x20) を指定する。dintno の下位 5 ビットは無視される。

      T-Kernel では、割込みコントローラに対する処理は何も行わない。割込みのク
      リア等は、割込みハンドラが処理しなければならない。

      多重割込を許可する場合、SR レジスタの割込マスクレベル(SR.I)を適切に変更
      することで多重割込を許可することができる。その場合、割込ハンドラを終了す
      る前に、割込マスクレベルを元に戻す必要がある。

      割込マスクレベルの設定は、割込コントローラ操作関数 SetIntLevel() で行う
      ことができる。

  (1) TA_HLNG の場合

      例外/割込ベクタテーブルには、T-Kernel 内の高級言語対応ルーチンのアドレス
      が設定され、高級言語対応ルーチンから指定されたハンドラを呼び出す。
      例外/割込ハンドラからの復帰は、関数からの return で行う。

      TLB ミス例外ハンドラ(dintno = 0x1020)には、TA_HLNG 属性は指定できない。

      例外/割込ハンドラは、次の形式となる。

      void inthdr( UINT dintno, UINT info )

        dintno  発生した例外/割込ベクタテーブルの割込番号
                デフォルトハンドラの場合、デフォルトハンドラの割込番号で
                はなく、発生した例外/割込の割込番号となる。

        info    追加情報
                TRAPA の場合    TRA の値
                その他の場合    不定

      例外/割込ハンドラに入ったときの CPU の状態は次のようになる。

        SR.MD = 1       特権モード
        SR.BL = 0       例外ブロック解除
        SR.RB = 0       レジスタバンク 0
        SR.FD = 0       FPU 使用許可
        SR.I = 15       割込禁止

  (2) TA_ASM の場合

      例外/割込ベクタテーブルには指定した例外/割込ハンドラのアドレスが設定され
      T-Kernel を経由せずに直接ハンドラが呼び出される。

      例外/割込ハンドラは、例外ブロック状態(SR.BL=1)で呼び出されるため、例外が
      発生しないよう注意する必要がある。したがって、TLB ミス例外が発生する可能
      性のある U0 領域に配置してはいけない。

      例外/割込ハンドラからの復帰は、tk_ret_int() システムコールを使用するか、
      INT_RETURN マクロを使用する。マクロを使用した場合、遅延ディスパッチは起
      こらない。マクロを使用する代わりに、独自にマクロに相当する処理を行っても
      よい。

      tk_ret_int() システムコールは、他のシステムコールとは異なる専用のトラップ
      により呼び出す。他のシステムコールのような関数形式の呼び出しはできない。

              TRAPA    #H'72       // tk_ret_int() 呼び出し (戻らない)

      tk_ret_int() を呼び出す時点で、復帰する必要のあるレジスタ等をすべて復帰
      し、例外/割込スタックを例外/割込ハンドラに入ったときと同じ状態にしておか
      なければならない。
      例外/割込スタックに保存されているレジスタは、tk_ret_int() により復帰さ
      る。

      例外/割込ハンドラ以外から tk_ret_int() を呼び出した場合の動作は保証され
      ない。

4.5 アラーム/周期ハンドラ

      アラーム/周期ハンドラでは、TA_ASM 属性に対応していないため、TA_ASM 属性
      を指定した場合も、TA_HLNG 属性の場合と同様に高級言語対応ルーチンを経由し
      て呼び出される。

4.6 タスク

      ER tk_cre_tsk( T_CTSK *ctsk )

      typedef struct t_ctsk {
              void    *exinf;         /* 拡張情報 */
              ATR     tskatr;         /* タスク属性 */
              FP      task;           /* タスク起動アドレス */
              PRI     itskpri;        /* タスク起動時優先度 */
              INT     stksz;          /* ユーザスタックサイズ(バイト) */
              INT     sstksz;         /* システムスタックサイズ(バイト) */
              void    *stkptr;        /* ユーザスタックポインタ */
              void    *uatb;          /* タスク固有空間ページテーブル */
              INT     lsid;           /* 論理空間ID */
              ID      resid;          /* リソースID */
              UB      dsname[8];      /* タスク名称 (DS用) */
      } T_CTSK;

  (1) オプション指定

      tskatr := (TA_ASM ‖ TA_HLNG)
              | [TA_SSTKSZ] | [TA_USERSTACK] | [TA_TASKSPACE] | [TA_RESID]
              | (TA_RNG0 ‖ TA_RNG1 ‖ TA_RNG2 ‖ TA_RNG3)
              | [TA_FPU]

      TA_COP0 が FPU に割り当てられる。他(TA_COP1～3)は使用しない。TA_FPU =
      TA_COP0 となる。
      FPU を使用する場合に TA_FPU を指定する。TA_FPU を指定した場合、TA_FPU を
      指定しない場合に比べ、FPU レジスタを退避するための領域(34*4 バイト)分だ
      け多くシステムスタックを消費する。
      FPU を使用しないことが明確な場合は、使用メモリの削減とコンテキストスイッ
      チのオーバーヘッドの削減のため、TA_FPU を指定しないことが望ましい。
      なお、実数を扱うライブラリなど FPU が使用できる前提で作成されているライ
      ブラリを使用する場合は TA_FPU を指定しなければならない。

      uatb と lsid に関しては、設定はできるが、使用されることはない。

  (2) タスクの形式

      タスクは次の形式で、TA_HLNG, TA_ASM のどちらを指定しても同じである。

      void task( INT stacd, void *exinf )

      タスク起動時のレジスタの状態は下記のようになる。

        SR.BL = 0       例外ブロック解除
        SR.RB = 0       レジスタバンク０
        SR.FD = 0       FPU 使用許可
        SR.I  = 0       割込許可
                        SR のその他のビットはすべて0

        MDR(R2_BANK1)   CPL = PPL = TA_RNGn で指定した保護レベル
        SST(R3_BANK1)   システムスタックトップ

        R4              タスク起動パラメータ(stacd)
        R5              タスク拡張情報(exinf)
        SP(R15)         TA_RNG0 の場合は、システムスタックポインタ
                        TA_RNG1～3 の場合は、ユーザスタックポインタ

        TA_FPU を指定した場合:
          FPSCR.FR = 0         FPU レジスタバンク 0
          FPSCR.SZ = 0         転送サイズ 32 ビット
          FPSCR.PR = 1         倍精度演算
          FPSCR.DN = 0         非正規化数を使用
          FPSCR.RM = 0         近傍への丸め
          FPSCR.Enable = 0     FPU 例外禁止

      その他のレジスタは不定である。

      SR レジスタの FD (FPU 使用可否) は、常に 0 であり、ユーザプログラムに
      よって変更してはいけない。

      タスクの終了は、tk_ext_tsk() または tk_exd_tsk() を用いなければならない。
      単に return してもタスクの終了とはならない。return した場合の動作は保証
      されない。

4.7 タスクのレジスタの設定／参照

  (1) タスクレジスタの設定／参照

      ER tk_set_reg( ID tskid, T_REGS *regs, T_EIT *eit, T_CREGS *cregs )
      ER tk_get_reg( ID tskid, T_REGS *regs, T_EIT *eit, T_CREGS *cregs )

      typedef struct t_regs {
            VW      r[15];      /* 汎用レジスタ R0～R14 */
            VW      mach;       /* 積和レジスタ MACH */
            VW      macl;       /* 積和レジスタ MACL */
            VP      gbr;        /* グローバルベースレジスタ GBR */
            VP      pr;         /* 関数レジスタ PR */
      } T_REGS;

      typedef struct t_eit {
            VP      pc;         /* プログラムカウンタ PC */
            UW      sr;         /* ステータスレジスタ SR */
            UW      mdr;        /* 動作モードレジスタ R2_BANK1 */ 
      } T_EIT;

      typedef struct t_cregs {
            VP      sstop;      /* システムスタックポインタ初期値 R3_BANK1 */
            VP      ssp;        /* システムスタックポインタ R15 */
            VP      usp;        /* ユーザスタックポインタ R15 */
            VP      uatb;       /* タスク固有空間ページテーブルのアドレス*/
            UW      lsid;       /* 論理空間ID */
            VW      r0;         /* R0_BANK1 レジスタ*/
            VW      r1;         /* R1_BANK1 レジスタ*/
      } T_CREGS;

      DORMANT 状態のタスクに対してレジスタの設定を行ったとき、R4, R5 は
      tk_sta_tsk() によってタスク起動パラメータ／拡張情報が設定されるため、
      tk_set_reg() で設定した値は捨てられることになる。

      SR レジスタの MD, BL, RB, FD, I の各ビットの設定は無視される。

      sstop の設定は無視される。

      usp は TA_RNG0 で動作するタスクでは意味を持たない。参照値は不定であり、
      設定は無視される。

      BANK1 の R4～R7 レジスタはタスク付属ではないため、参照/設定できない。

  (2) コプロセッサレジスタの設定／参照

      ER tk_set_cpr( ID tskid, INT copno, T_COPREG *copreg )
      ER tk_get_cpr( ID tskid, INT copno, T_COPREG *copreg )

      typedef struct t_cop0regs {
            float   fr[16];     /* FPU バンク0 レジスタ FR0～15 */
            float   xf[16];     /* FPU バンク1 レジスタ XF0～15 */
            UW      fpul;       /* 通信レジスタ*/
            UW      fpscr;      /* 制御レジスタ*/
      } T_COP0REGS;

      typedef union {
            T_COP0REGS  cop0;   /* FPU レジスタ */
      #if 0
            T_COP1REGS  cop1;   /* なし */
            T_COP2REGS  cop2;   /* なし */
            T_COP3REGS  cop3;   /* なし */
      #endif
      } T_COPREGS;

      copno = 0 で、FPU のレジスタの参照/設定が可能。copno = 1～3 は E_PAR と
      なる。TA_FPU を指定していないタスクでは、copno = 0 でも E_PAR となる。

4.8 タスク例外ハンドラ

      タスク例外ハンドラは、レジスタの保存/復帰を行う専用のエントリルーチンを
      持つ必要がある。エントリルーチンには、マクロ TEXHDR_ENTRY を使用する。
      または、これに相当する処理を独自に行ってもよい。

      タスク例外ハンドラに入るときのスタックの状態

                  +---------------+
       SP(R15) -> | save SR       | ハンドラからの戻り時に復帰する SR
                  | retadr        | ハンドラからの戻りアドレス
                  | texcd         | 例外コード
                  +---------------+

      標準で用意されているマクロ TEXHDR_ENTRY は、FPU が使用可能である前提で作
      成されているため、TA_FPU 属性を指定しないタスクのタスク例外ハンドラとし
      ては使用できない。このような場合は、FPU レジスタの保存/復帰の処理を省い
      たタスク例外ハンドラのエントリルーチンを別途作成する必要がある。

      マクロ TEXHDR_ENTRY は、以下に用意されている。

              include/tk/asm.h (.inc)
                 --> include/tk/sysdepend/asp_sh7750r/asm_depend.h (.inc)

4.9 システムコール/拡張 SVC 呼び出し元情報

      td_hok_svc() によるフックルーチンに渡される、システムコール/拡張 SVC 呼
      び出し元情報の形式は次のようになる。

      typedef struct td_calinf {
             VP      ssp;       /* システムスタックポインタ */
             VP      pr;        /* 呼出時の PR レジスタ */
             VP      r14;       /* 呼出時のフレームポインタ */
      } TD_CALINF;

      フックルーチンに入ったときのシステムスタックは以下の状態となる。

                +---------------+
          ssp-> | SPC           |
                | SSR           |
                | MDR(R2_BANK1) |
                +---------------+
                | USP(R15)      | システムスタックへの切替があった場合のみ
                +---------------+

      USP はユーザスタックポインタで、システムスタックへの切替があった場合のみ
      保存される。

      システムコール/拡張 SVC からの戻り番地は SPC である。しかし、通常はイン
      タフェースライブラリを利用して呼び出すため、SPC はインタフェースライブラ
      リの番地を指している。
      インタフェースライブラリからの戻り番地は pr となる。ただし、標準のインタ
      フェースライブラリを使用していない場合は、この限りではない。

      なお、呼び出し前のフックルーチンは、必ず以下の形式の可変引数の宣言としな
      くてはいけない。異なる宣言をした場合は、システムコール/拡張 SVC の引数が
      正しく渡されない。

        VP enter( FN fncd, TD_CALINF *calinf, ... )

4.10 システムメモリ管理およびアドレス空間管理

  (1) システムメモリの割り当て

      tk_get_smb() の属性指定(attr)により、獲得するメモリ領域は以下の通り。
      ・TA_NORESIDENT 属性の指定は無視される。

        属性指定               獲得するメモリ領域
                        メモリ保護なし  メモリ保護あり
        --------------------------------------------------
        TA_NOCHAE 指定     P2 領域         P2 領域
        TA_RNG0   指定     P1 領域         P1 領域
        TA_RNG1   指定     P1 領域         P1 領域
        TA_RNG2   指定     P1 領域         U0 領域
        TA_RNG3   指定     P1 領域         U0 領域

      メモリのブロックサイズは、以下の通り。
        メモリ保護なしのとき    2 KB
        メモリ保護ありのとき    4 KB

  (2) メモリプールの生成

      tk_cre_mpf(), tk_cre_mpl() の属性指定(attr)により、獲得するメモリ領域は
      以下の通り。

        属性指定               獲得するメモリ領域
                        メモリ保護なし  メモリ保護あり
        --------------------------------------------------
        TA_RNG0   指定     P1 領域         P1 領域
        TA_RNG1   指定     P1 領域         P1 領域
        TA_RNG2   指定     P1 領域         U0 領域
        TA_RNG3   指定     P1 領域         U0 領域

  (3) メモリ獲得/解放ライブラリ
  
      Kmalloc(), Kcalloc(), Krealloc(), Kfree()
      Vmalloc(), Vcalloc(), Vrealloc(), Vfree()

        メモリ保護なし/ありに無関係に、常に獲得したメモリは、P1 領域に割り当て
        られる。

      Smalloc(), Scalloc(), Srealloc(), Sfree()

        メモリ保護なしのとき、獲得したメモリは、P1 領域に割り当てられる。
        メモリ保護ありのとき、獲得したメモリは、U0 領域に割り当てられる。

      malloc(), calloc(), realloc(), free()

        Smalloc(), Scalloc(), Srealloc(), Sfree() と同じ。

  (4) アドレス空間の操作
  
      アドレス空間チェックは常にアクセス許可となる。
      アドレス空間のロック/アンロックは意味を持たない。

  (5) 物理アドレスの取得

      CnvPhysicalAddr() は、非キャッシュ領域(P2領域)にアドレスを変換し、キャッ
      シュをフラッシュ(ライトバックして無効化)する。

  (6) メモリのマップ

      MapMemory() の動作は以下の通り。

      paddr != NULL (メモリマップ) の場合 :
          MM_CDIS 指定の場合、paddr に対応する非キャッシュ領域(P2領域)のアドレ
          スを戻し、そうでない場合、paddr をそのまま戻す。
          指定したメモリ領域のキャッシュをフラッシュする。
          他の属性は無視される。

      paddr == NULL (メモリ獲得) の場合 :
          MM_CDIS 指定の場合、非キャッシュ領域(P2領域)のメモリを獲得、
          メモリ保護ありで、MM_USER 指定の場合は、U0 領域のメモリを獲得、
          それ以外の場合は、P1 領域のメモリを獲得する。

4.11 CPU 割込制御

      以下の CPU 割込制御マクロ関数は、SR レジスタの 割込マスクレベル(IMASK)を
      15 に設定することにより割込みを禁止し、元の値に戻すことにより許可する。

        DI( UINT intsts )       割込禁止
        EI( UINT intsts )       割込許可 (以前の状態へ復帰)

4.12 割込コントローラ操作

  (1) 割込ベクタ(INTVEC)の値

      割込ベクタ(INTVEC)の値として割込番号 (0x200～0xDE0)を使用する。
      1 つの周辺モジュールで、複数の割込番号を持つ場合は、最も小さな割込番号を
      を使用する。

      割込コントローラの操作関数で intvec として指定可能な値は、以下の通り。
      他の値を指定した場合の動作は保証しない。

        #define IV_TMU0         0x400   /* タイマ #0 */
        #define IV_TMU1         0x420   /* タイマ #1 */
        #define IV_TMU2         0x440   /* タイマ #2 */
        #define IV_RTC          0x480   /* リアルタイムクロック */
        #define IV_SCI          0x4e0   /* シリアル */
        #define IV_WDT          0x560   /* ウォッチドックタイマ */
        #define IV_REF          0x580   /* メモリリフレッシュ */
        #define IV_HUDI         0x600   /* ユーザデバッグインタフェース */
        #define IV_GPIO         0x620   /* I/O ポート */
        #define IV_DMAC         0x640   /* DMA */
        #define IV_SCIF         0x700   /* FIFO 付シリアル */

  (2) 割込みの許可

        void EnableInt( INTVEC intvec, INT level )

      intvec で指定した割込みの優先レベルを level に設定し割込みを許可する。
      level は 1～15 の範囲が有効で、15 が最も優先度が高い。
      level に無効な値が指定された場合の動作は保証されない。
      INTMSK00 レジスタは操作しないので、必要に応じて設定する必要がある。

  (3) 割込みの禁止

        void DisableInt( INTVEC intvec )

      intvec で指定した割込みの優先レベルを 0 に設定し割込みを禁止する。
      INTMSK00 レジスタは操作しないので、必要に応じて設定する必要がある。

  (4) 割込マスクレベルの設定

        UINT  SetIntLevel( INT level )

        戻値  変更前の SR レジスタの値 (level は、bit4 - bit7)

      CPU の SR レジスタの割込マスクレベル(IMASK)を level に設定する。
      level は 0～15 の範囲が有効で、0 が全割込優先レベルの許可となる。

      割込ハンドラ内で多重割込を許可する場合に使用する。通常、自身の割込優先レ
      ベルを level に指定し、より高い優先レベルの割込みを許可する。

4.13 物理タイマ

      以下の 2 つの物理タイマに対応している。

      No Unit Clock(Hz) Resolution(usec) Max counts (h:m:s)     Handler
      -----------------------------------------------------------------
      1  TMU1   7500000       0.1333     0xFFFFFFFF (00:09:32)  True
      2  TMU2   7500000       0.1333     0xFFFFFFFF (00:09:32)  True

      物理タイマのクロックは以下のいずれかを選択可能であり、デフォールトで
      上記の設定としている。(ソースを修正することにより変更は可能)

              Clock(Hz) Resolution(usec) Max time(h:m:s)
      -----------------------------------------------------------
      Pclk/4   7500000        0.1333     00:09:32
      Pclk/16  1875000        0.5333     00:38:10
      Pclk/64   468750        2.1333     02:32:42
      Pclk/256  117187        8.5333     10:10:50
      Pclk/1024  29296       34.1333     40:43:20
      ( Pclk: 周辺クロック = 30 MHz )

4.14 メモリキャッシュ制御機能

      これらの機能は、ごく一部の特殊なプログラムで使用することを前提とした物で
      あり、一般的には使用しないことを推奨する。
      操作対象となるアドレス領域によっては、誤動作の原因となることがある。

  (1) キャッシュモードの設定

      INT SetCacheMode( const void *addr, INT len, UINT mode )

      常に E_NOSPT を返す。

  (2) キャッシュの制御

      INT ControlCache( const void *addr, INT len, UINT mode )

      指定可能な mode は以下の通り。

      mode := [CC_FLUSH] | [CC_INVALIDATE]

      CC_FLUSH        キャッシュの書き戻し
      CC_INVALIDATE   キャッシュの無効化

      キャッシュ制御の対象は、指定されたアドレスを含むページ単位の領域となる。

4.15 論理アドレス空間管理

      これらの機能は、ごく一部の特殊なプログラムで使用することを前提とした物で
      あり、一般的には使用しないことを推奨する。
      操作対象となるアドレス領域によっては、誤動作の原因となることがある。

  (1) アドレス空間情報の取得

      ER GetSpaceInfo( const void *addr, INT len, T_SPINFO *pk_spinfo )

      typedef struct {
              VP      paddr;  /* addr に対応する物理アドレス */
              VP      page;   /* addr が属するページの先頭物理アドレス */
              INT     pagesz; /* ページサイズ(バイト数) */
              INT     cachesz;/* キャッシュラインサイズ(バイト数) */
              INT     cont;   /* 物理アドレスの連続領域のサイズ(バイト数) */
      } T_SPINFO;

  (2) メモリアクセス権の設定

      INT SetMemoryAccess( const void *addr, INT len, UINT mode )

      常に E_NOSPT を返す。

4.16 その他の実装依存機能

  (1) SR レジスタロード機能

      ユーザモードで動作するプログラムで SR レジスタへの書き込みを行う機能。
      タスク例外ハンドラで使用するために用意されている。

        R0      SR レジスタ設定値 (MD, BL, RB, FD, I は設定不可)
        TRAPA   #H'75

  (2) ユーザ高速ロック機能

      以下の高速ロック機能の関数では、内部で割込み禁止/許可の操作を行うため、
      ユーザモードで動作するプログラムからは使用できない。

        ER CreateLock( FastLock *lock, CONST UB *name )
        void DeleteLock( FastLock *lock )
        void Lock( FastLock *lock )
        void Unlock( FastLock *lock )

        ER CreateMLock( FastMLock *lock, CONST UB *name )
        ER DeleteMLock( FastMLock *lock )
        ER MLockTmo( FastMLock *lock, INT no, TMO tmout )
        ER MLockTmo_u( FastMLock *lock, INT no, TMO_U tmout_u )
        ER MLock( FastMLock *lock, INT no )
        ER MUnlock( FastMLock *lock, INT no )

      そのため、ユーザモードで動作するプログラムからは同等の機能を持つ以下の関
      数を使用すること。

        ER CreateULock( FastULock *lock, CONST UB *name )
        void DeleteULock( FastULock *lock )
        void ULock( FastULock *lock )
        void UUnlock( FastULock *lock )

        IMPORT ER CreateUMLock( FastUMLock *lock, CONST UB *name )
        ER DeleteUMLock( FastUMLock *lock )
        ER UMLockTmo( FastUMLock *lock, INT no, TMO tmout )
        ER UMLockTmo_u( FastUMLock *lock, INT no, TMO_U tmout_u )
        ER UMLock( FastUMLock *lock, INT no )
        ER UMUnlock( FastUMLock *lock, INT no )

  (3) メモリ保護機能の実装

      メモリ保護機能では、以下の形式のページテーブルを使用する。ページサイズは
      4 KB 固定である。

        ページテーブル(全体):

                先頭仮想ページ番号                      [ 4 byes ]
                最終仮想ページ番号 + 1                  [ 4 byes ]
                ページテーブルエントリ (先頭仮想ページ) [ 1 byte ]
                        ::::
                ページテーブルエントリ (最終仮想ページ) [ 1 byte ]

        ページテーブルエントリ: 1 バイト/ページ

                未割当ページ : 0
                割当済ページ : 以下の内容 (PTEL レジスタのビット7 - 0 と同じ)

                      7   6   5   4   3   2   1   0
                    +---+---+---+---+---+---+---+---+
                    |SZ1|   PR  |SZ2| C | D | SH| WT|
                    +---+---+---+---+---+---+---+---+

                    SZ1 = 0   : 4 K バイトページ(固定)
                    SZ2 = 1   : 4 K バイトページ(固定)
                    PR  = 00  : 特権モードで読込のみ可能    (未使用)
                        = 01  : 特権モードで読込/書込可能   (未使用)
                        = 10  : 特権/ユーザモードで読込のみ可能
                        = 11  : 特権/ユーザモードで読込/書込可能
                    C   = 1   : キャッシング可能
                    D   = 1   : ダーティ(初期ページ書き込み例外発生を回避)
                    SH  = 0   ; 非共有
                    WT  = 0   : コピーバックモード

      T-Kernel 起動時に、U0 領域の以下のアドレス範囲に対応するページテーブル領
      域を動的メモリ領域の直前に獲得し、初期化を行う。

                動的メモリ領域 (ram_top ～ ram_end)
                        ページテーブルエントリ未割当て (= 0)
                ユーザプログラムコード領域 (s_usr_code ～ e_usr_code) :
                        ページテーブルエントリ割当て (PR=10)
                ユーザプログラムデータ領域 (s_usr_data ～ e_usr_data) :
                        ページテーブルエントリ割当て (PR=11)
                先頭仮想ページ番号:
                        上記の 3 つの領域の最小ページ番号
                最終仮想ページ番号:
                        上記の 3 つの領域の最大ページ番号

                例えば、仮想ページ範囲が、2 MB とすると、ページテーブルの全体
                サイズは、( 8 + 512 ) バイトとなる。

      ページテーブルのアドレスは、TTB レジスタに設定され、以後 TTB レジスタは
      変更されることはない。

      TLB ミス例外ハンドラでは、例外の発生した論理ページに対して以下の処理を
      行う。

        ・先頭～最終仮想ページ番号の範囲外のとき、メモリ保護違反として、デフォ
          ールトハンドラに飛ぶ。
        ・対応するページテーブルエントリが未割当(=0)のとき、メモリ保護違反とし
          て、デフォールトハンドラに飛ぶ。
        ・対応するページテーブルエントリを PTEL として、TLB に登録する。PTEH に
          設定する物理ページは論理ページを同じとする。

      動的メモリの獲得(tk_get_smb()など)で、TA_RNG2 または TA_RNG3 が指定され
      た場合、以下の処理を行う。

        ・獲得した P1 領域のアドレスを U0 領域のアドレスに変換する。
        ・対応するページテーブルエントリを割当て(PR=11)に設定する。

      この結果、獲得した動的メモリをアクセスすると、TLB ミス例外が発生し、TLB
      ミス例外ハンドラが起動し、対応する割当て済みのページテーブルエントリが
      TLB に登録され、ユーザプログラムから読込/書込可能となる。

      動的メモリの解放(tk_rel_smb()など)で、U0 領域のアドレスが指定された場合
      以下の処理を行う。

        ・P1 領域のアドレスに変換して正当なアドレスかどうかをチェックする。
        ・対応するページテーブルエントリを未割当て(=0)に設定する。
        ・対応するページの TLB を無効化する。

      この結果、解放した動的メモリをアクセスすると、TLB ミス例外が発生し、TLB
      ミス例外ハンドラが起動するが、ページテーブルエントリが未割当てなため、メ
      モリ保護違反となる。

以上
